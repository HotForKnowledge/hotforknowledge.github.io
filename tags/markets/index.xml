<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hot For Knowledge</title>
    <link>http://hotforknowledge.com/tags/markets/index.xml</link>
    <description>Recent content on Hot For Knowledge</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Victor Baybekov</copyright>
    <atom:link href="http://hotforknowledge.com/tags/markets/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>How to write the simplest trading strategy using Spreads</title>
      <link>http://hotforknowledge.com/2015/12/29/2-how-to-write-the-simplest-trading-strategy-using-spreads/</link>
      <pubDate>Tue, 29 Dec 2015 17:51:27 +0300</pubDate>
      
      <guid>http://hotforknowledge.com/2015/12/29/2-how-to-write-the-simplest-trading-strategy-using-spreads/</guid>
      <description>&lt;p&gt;I am always amused when retail traders are offered and then do use black boxes with complex frameworks to build automatic trading strategies. Usually that goes with an explanation how cool those platforms are and how easy to build a strategy using them. They forget about vendor lock-in and the most terrible model of &lt;em&gt;shared state with events hell&lt;/em&gt; like &amp;ldquo;OnData&amp;rdquo;, &amp;ldquo;OnOrder&amp;rdquo;, &amp;ldquo;OnBarOpen&amp;rdquo;, &amp;ldquo;OnBarClose&amp;rdquo;, etc. The more I talk with people, the more I realize that &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Complex_event_processing&#34;&gt;CEP&lt;/a&gt;&lt;/strong&gt; is the approach that desks and serious traders use.&lt;/p&gt;

&lt;p&gt;Spreads is not a framework for financial markets but a generic CEP library that allows to model markets as &lt;em&gt;data series&lt;/em&gt; and use pure math and functional data transformations.&lt;/p&gt;

&lt;p&gt;The simplest trivial example is &lt;em&gt;simple moving average &lt;/em&gt;trend following strategy. This example is written in F# interactive console.  First, we generate trending artificial data where trend changes each 40 points:
&lt;pre class=&#34;lang:default decode:true&#34;&gt;let quotes : Series&amp;lt;DateTime, float&amp;gt; = // data is produced outside
    let mutable previous = 1.0
    let sm = SortedMap()
    let now = DateTime.UtcNow
    let mutable trend = -1.0
    let mutable cnt = 0
    for i in 0..500 do
      previous &amp;lt;- previous*(1.0 + rng.NextDouble()*0.002 - 0.001 + 0.001 * trend)
      sm.Add(now.AddSeconds(-((500-i) |&amp;gt; float)*0.2), previous)
      cnt &amp;lt;- cnt + 1
      if cnt % 40 = 0 then trend &amp;lt;- -trend&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Task.Run((fun _ -&amp;amp;gt;

    while not ct.IsCancellationRequested do
      Thread.Sleep(500)
      previous &amp;amp;lt;- previous*(1.0 + rng.NextDouble()*0.002 - 0.001 + 0.001 * trend)
      sm.Add(DateTime.UtcNow, previous)
      cnt &amp;amp;lt;- cnt + 1
      if cnt % 40 = 0 then trend &amp;amp;lt;- -trend
  ), ct) |&amp;amp;gt; ignore
sm :&amp;amp;gt; Series&amp;amp;lt;DateTime, float&amp;amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we calculate simple moving average over 20 points. The second argument allows using incomplete windows, e.g. for the first 10 data points the average is calculated over them. With false, the first SMA point is calculated only at the 20th quotes point.
&lt;pre class=&#34;lang:default decode:true &#34;&gt;let sma = quotes.SMA(20, true)&lt;/pre&gt;
Our trading rule is that if the current price is above SMA, we go long, and we go short otherwise. This is a classic trend following strategy and it works quite well in the long run on emerging markets and some commodities. We calculate our target position as:
&lt;pre class=&#34;lang:default decode:true&#34;&gt;let targetPosition = (quotes / sma - 1.0).Map(fun deviation -&amp;gt; double &amp;lt;| Math.Sign(deviation))
&lt;/pre&gt;
This target position series is live - its values are updated in real-time together with quotes. To execute our strategy, we must prepare storage for actual positions and trades:
&lt;pre class=&#34;lang:default decode:true &#34;&gt;// we must keep track of actual position
let actualPositionWritable = SortedMap&amp;lt;DateTime,float&amp;gt;()
let realTrades = SortedMap&amp;lt;DateTime,float&amp;gt;()
let actualPosition = actualPositionWritable :&amp;gt; Series&amp;lt;&lt;em&gt;,&lt;/em&gt;&amp;gt;
actualPosition.Do((fun k v -&amp;gt;
    Console.WriteLine(&amp;ldquo;Actual position: &amp;ldquo; + k.ToString() + &amp;rdquo; : &amp;ldquo; + v.ToString())
  ), ct)&lt;/pre&gt;
Then we could feed our target position to a trader. Trader is &amp;ldquo;functional&amp;rdquo;, instead of receiving orders it receives desired state and does its best to move actual state to the desired state. Here for simplicity we have a very dangerous assumption that trades are executed  immediately after a signal. Such an assumption should be avoided in real world backtesting. &lt;span style=&#34;line-height: 1.5;&#34;&gt;We use &lt;/span&gt;&lt;em style=&#34;line-height: 1.5;&#34;&gt;Do()&lt;/em&gt;&lt;span style=&#34;line-height: 1.5;&#34;&gt; extension method that invokes an action over each key/value in a series sequentially:&lt;/span&gt;
&lt;pre class=&#34;lang:default decode:true &#34;&gt;targetPosition.Do(
  (fun k v -&amp;gt;
    if k &amp;lt;= DateTime.UtcNow.AddMilliseconds(-400.0) then
      // simulate historical trading
      let qty =
        if actualPositionWritable.IsEmpty then v
        else (v - actualPositionWritable.Last.Value)
      if qty &amp;lt;&amp;gt; 0.0 then
        Console.WriteLine(k.ToString() +  &amp;ldquo; : Paper trade: &amp;ldquo; + qty.ToString())
        actualPositionWritable.AddLast(k, v)
    else
      // do real trading
      let qty =
        if actualPositionWritable.IsEmpty then failwith &amp;ldquo;must test strategy before real trading&amp;rdquo;
        else (v - actualPositionWritable.Last.Value)
      if qty &amp;lt;&amp;gt; 0.0 &amp;amp;&amp;amp; k &amp;gt; actualPositionWritable.Last.Key then // protect from executing history
        let tradeTime = DateTime.UtcNow.AddMilliseconds(5.0)
        Console.WriteLine(tradeTime.ToString() +  &amp;ldquo; : Real trade: &amp;ldquo; + qty.ToString())
        realTrades.AddLast(tradeTime, qty)
        actualPositionWritable.AddLast(tradeTime, v)
  ), ct)&lt;/pre&gt;
Now the trading is started and we could see our trades in the FSI console every several seconds.&lt;/p&gt;

&lt;p&gt;Finally, we calculate our P&amp;amp;L. Because the market was trending by construction, we have earned a lot of money with this strategy:
&lt;pre class=&#34;lang:default decode:true&#34;&gt;let returns = quotes.ZipLag(1u, fun c p -&amp;gt; c/p - 1.0)
let myReturns = actualPosition.Repeat() * returns
let myAumIndex = myReturns.Scan(1.0, fun st k v -&amp;gt; st*(1.0 + v))&lt;/pre&gt;
Here, we use &lt;em&gt;ZipLag()&lt;/em&gt; to calculate price returns. Then we calculate returns of our position and aggregate them as running product (no trading costs in this example). All these and above series are live, we could use the &lt;em&gt;Do()&lt;/em&gt; method to print the values in real-time:
&lt;pre class=&#34;lang:default decode:true &#34;&gt;// Print live data
myAumIndex.Do((fun k v -&amp;gt;
    Console.WriteLine(&amp;ldquo;AUM Index: &amp;ldquo; + k.ToString() + &amp;rdquo; : &amp;ldquo; + v.ToString())
  ), ct)&lt;/pre&gt;
&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Note that from the technical point of view there is nothing special that links the calculations to financial markets. Instead of financial data, we could use data from some sensors, e.g. temperature, and instead of trading we could turn off/on heating if temperature goes above or below some target value.&lt;/p&gt;

&lt;p&gt;The whole example is &lt;a href=&#34;https://github.com/Spreads/Spreads/blob/master/tests/Spreads.Tests.Profile/Example.fsx&#34;&gt;here&lt;/a&gt;. You could select all code, press Alt+Enter and watch how AUM increases while using Spreads library! :)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>